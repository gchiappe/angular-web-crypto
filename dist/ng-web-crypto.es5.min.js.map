{"version":3,"sources":["ng-web-crypto.es5.js"],"names":["NgWebCryptoUtils","this","ABtoString","buffer","str","iii","byteLength","String","fromCharCode","StringtoAB","bytes","Uint8Array","length","charCodeAt","isFunction","obj","constructor","call","apply","isDefined","variable","ABToHS","uint8arr","hexStr","i","hex","toString","toUpperCase","HSToAB","a","len","push","parseInt","substr","angular","module","provider","$injector","_this","crypto","window","subtle","tools","instantiate","keys","cryptoKeys","getKey","kName","c","name","getCryptoKey","defaultKey","defaultCryptoKey","generateKey","options","random","getRandomValues","console","error","namedCurve","type","promise","Promise","resolve","reject","then","key","gRaw","gJwk","exportKey","publicKey","eJwk","eRaw","class","jwk","raw","catch","err","success","fn","getDefaultKeys","ecdh","checkKey","checkCryptoKey","importKey","crv","format","importDataObj","keyCapabilities","x","y","d","kty","ext","default","derive","privateKeyName","publicKeyName","targetClass","targetLength","exportable","deriveKey","public","privateKey","log","encrypt","data","tagLength","encIV","iv","encrypted","decrypt","dec","decrypted","$get","$webCryptoProvider","ArrayBufferToHexString","ab","HexStringToArrayBuffer","hs","ArrayBufferToString","StringToArrayBuffer","import","newName","importAndDeriveWithDefaultKey","defKeys","importName","rsaKeyName","importedKeyName","derivedKeyName","importAndDerive","export","exportDefaultKey","encryptWithDefaultKey","decryptWithDefaultKey","factory","$webCrypto","$http","post","server","arguments","undefined","ucdata_str","JSON","stringify","encData","rdata","status","headers","config","statusText","indexOf","rdatao","split","rivo","parsed","parse","e","resultObj","p"],"mappings":"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","file":"ng-web-crypto.es5.min.js","sourcesContent":["/*\nngWebCrypto\n---\nThe MIT License (MIT)\n\ncopyright ©2016 Giancarlo A. Chiappe Aguilar\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n---\n©2016 Giancarlo Chiappe Aguilar <gchiappe@outlook.com.pe>\n*/\n'use strict';\n\nvar NgWebCryptoUtils = function () {\n    function NgWebCryptoUtils() {\n        this.ABtoString = function (buffer) {\n            var str = \"\";\n            for (var iii = 0; iii < buffer.byteLength; iii++) {\n                str += String.fromCharCode(buffer[iii]);\n            }\n            return str;\n        };\n        this.StringtoAB = function (str) {\n            var bytes = new Uint8Array(str.length);\n            for (var iii = 0; iii < str.length; iii++) {\n                bytes[iii] = str.charCodeAt(iii);\n            }\n            return bytes;\n        };\n        this.isFunction = function (obj) {\n            return !!(obj && obj.constructor && obj.call && obj.apply);\n        };\n        this.isDefined = function (variable) {\n            if (typeof variable === 'undefined' || variable === null) {\n                return false;\n            }\n            return true;\n        };\n        this.ABToHS = function (uint8arr) {\n            if (!uint8arr) {\n                return '';\n            }\n            var hexStr = '';\n            for (var i = 0; i < uint8arr.length; i++) {\n                var hex = (uint8arr[i] & 0xff).toString(16);\n                hex = hex.length === 1 ? '0' + hex : hex;\n                hexStr += hex;\n            }\n            return hexStr.toUpperCase();\n        };\n        this.HSToAB = function (str) {\n            if (!str) {\n                return new Uint8Array();\n            }\n            var a = [];\n            for (var i = 0, len = str.length; i < len; i += 2) {\n                a.push(parseInt(str.substr(i, 2), 16));\n            }\n            return new Uint8Array(a);\n        };\n    }\n    return NgWebCryptoUtils;\n}();\nangular.module('ngWebCrypto', []);\nangular.module('ngWebCrypto').provider('$webCrypto', function ($injector) {\n    var _this = this;\n\n    var crypto = window.crypto;\n    if (!crypto.subtle) {\n        throw 'ng-web-crypto: browser not supported.';\n    }\n    var tools = $injector.instantiate(NgWebCryptoUtils);\n    //almacenes: almacenar los cripto-objetos en variables de una funcion anonima.\n    var keys = []; // llaves ECDH\n    var cryptoKeys = []; // llaves criptograficas (def. AES-GCM)\n    // llaves ECDH\n    var getKey = function getKey(kName) {\n        for (var c = 0; c < keys.length; c++) {\n            if (keys[c].name == kName) {\n                return keys[c];\n            }\n        }\n        return -1;\n    };\n    // llaves AES\n    var getCryptoKey = function getCryptoKey(kName) {\n        for (var c = 0; c < cryptoKeys.length; c++) {\n            if (cryptoKeys[c].name == kName) {\n                return cryptoKeys[c];\n            }\n        }\n        return -1;\n    };\n    var defaultKey = null,\n        defaultCryptoKey = null;\n    // Funciones del proveedor:\n    this.generateKey = function (options) {\n        if (tools.isDefined(options.random)) {\n            if (options.random) {\n                options.name = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n            }\n        }\n        if (!tools.isDefined(options.name)) {\n            console.error('key name is required for generating.');\n            return;\n        }\n        if (getKey(options.name) != -1) {\n            console.error('key name \"', options.name, '\" already in use.');\n            return;\n        }\n        if (!tools.isDefined(options.namedCurve)) {\n            options.namedCurve = 'P-256';\n        }\n        if (!tools.isDefined(options.type)) {\n            options.type = 'private';\n        }\n        if (!(options.type == 'private' || options.type == 'public' || options.type == 'mixed')) {\n            console.error('invalid key type (private, public, mixed).');\n            return;\n        }\n        // == Crear Promesa\n        var promise = new Promise(function (resolve, reject) {\n            // == Crear Llave\n            crypto.subtle.generateKey({\n                name: 'ECDH',\n                namedCurve: options.namedCurve\n            }, true, ['deriveKey', 'deriveBits']).then(function (key) {\n                var gRaw, gJwk;\n                crypto.subtle.exportKey('jwk', key.publicKey).then(function (eJwk) {\n                    gJwk = eJwk;\n                    crypto.subtle.exportKey('raw', key.publicKey).then(function (eRaw) {\n                        gRaw = eRaw;\n                        keys.push({\n                            class: 'ECDH',\n                            type: options.type,\n                            name: options.name,\n                            key: key,\n                            jwk: gJwk,\n                            raw: gRaw\n                        });\n                        if (getKey(options.name) != -1) {\n                            if (!tools.isDefined(defaultKey)) defaultKey = options.name;\n                            resolve(options.name);\n                        } else {\n                            reject('key was not added to storage.');\n                        }\n                    });\n                });\n            }).catch(function (err) {\n                reject(err);\n            });\n        });\n        promise.success = function (fn) {\n            promise.then(function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        promise.error = function (fn) {\n            promise.then(null, function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        return promise;\n    };\n    this.getDefaultKeys = function () {\n        return {\n            ecdh: defaultKey,\n            crypto: defaultCryptoKey\n        };\n    };\n    this.checkKey = function (kName) {\n        return getKey(kName) != -1;\n    };\n    this.checkCryptoKey = function (kName) {\n        return getCryptoKey(kName) != -1;\n    };\n    this.importKey = function (options) {\n        if (!tools.isDefined(options.name)) {\n            console.error('key name is required for importing.');\n            return;\n        }\n        if (_this.checkKey(options.name)) {\n            console.error('key name \"', options.name, '\" already in use.');\n            return;\n        }\n        if (!tools.isDefined(options.crv)) options.crv = 'P-256';\n        if (!tools.isDefined(options.format)) options.format = 'raw';\n        if (!tools.isDefined(options.type)) options.type = 'public';\n        var importDataObj = void 0;\n        var keyCapabilities = [];\n        if (options.format == 'jwk') {\n            if (!tools.isDefined(options.x) || !tools.isDefined(options.y) || !tools.isDefined(options.d)) {\n                throw 'x, y and d parameters are required to import an ECDH key.';\n            }\n            importDataObj = {\n                kty: 'EC',\n                crv: options.crv,\n                x: options.x,\n                y: options.y,\n                d: options.d,\n                ext: true\n            };\n            if (options.type == 'private') keyCapabilities = ['deriveKey', 'deriveBits'];\n        } else {\n            if (!tools.isDefined(options.raw)) {\n                throw 'raw parameter is missing.';\n            }\n            importDataObj = tools.HSToAB(options.raw);\n        }\n        var promise = new Promise(function (resolve, reject) {\n            crypto.subtle.importKey(options.format, importDataObj, {\n                name: 'ECDH',\n                namedCurve: options.crv\n            }, true, keyCapabilities).then(function (key) {\n                var gRaw = void 0,\n                    gJwk = void 0;\n                crypto.subtle.exportKey('jwk', key).then(function (eJwk) {\n                    gJwk = eJwk;\n                    crypto.subtle.exportKey('raw', key).then(function (eRaw) {\n                        gRaw = eRaw;\n                        keys.push({\n                            class: 'ECDH',\n                            type: options.type,\n                            name: options.name,\n                            key: { publicKey: key },\n                            jwk: gJwk,\n                            raw: gRaw\n                        });\n                        if (getKey(options.name) != -1) {\n                            resolve(options.name);\n                        } else {\n                            reject('key was not added to storage.');\n                        }\n                    });\n                });\n            }).catch(function (err) {\n                reject('error catched.');\n                throw err;\n            });\n        });\n        promise.success = function (fn) {\n            promise.then(function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        promise.error = function (fn) {\n            promise.then(null, function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        return promise;\n    };\n    this.exportKey = function (options) {\n        // == Chequeo\n        if (tools.isDefined(options.default)) {\n            if (options.default) if (tools.isDefined(defaultKey)) {\n                options.name = defaultKey;\n            } else {\n                console.error('default key is not defined.');\n                return;\n            }\n        }\n        if (!tools.isDefined(options.name)) {\n            console.error('key name is required for exporting keys.');\n            return;\n        }\n        if (getKey(options.name) == -1) {\n            console.error('Key \"', options.name, '\" not found.');\n            return;\n        }\n        // == Defectos\n        if (!tools.isDefined(options.type)) {\n            options.type = 'raw';\n        }\n        if (options.type == 'jwk') {\n            if (tools.isDefined(getKey(options.name).jwk)) return getKey(options.name).jwk;else {\n                console.error('the key \"', options.name, '\" cannot be exported.');\n                return;\n            }\n        } else if (options.type == 'raw') {\n            if (tools.isDefined(getKey(options.name).raw)) return tools.ABToHS(new Uint8Array(getKey(options.name).raw));else {\n                console.error('the key \"', options.name, '\" cannot be exported.');\n                return;\n            }\n        } else {\n            console.error('invalid export type');\n            return;\n        }\n    };\n    this.derive = function (options) {\n        // == Chequeo de errores\n        if (!tools.isDefined(options.name)) {\n            console.error('key name is required for deriving ECDH keys.');\n            return;\n        }\n        if (getCryptoKey(options.name) != -1) {\n            console.error('key name \"', options.name, '\" already in use.');\n            return;\n        }\n        if (!tools.isDefined(options.privateKeyName) || !tools.isDefined(options.publicKeyName)) {\n            console.error('deriving keys require two previously stored keys.');\n            return;\n        }\n        if (getKey(options.privateKeyName) == -1) {\n            console.error('private key \"', options.privateKeyName, '\" not found.');\n            return;\n        }\n        if (getKey(options.publicKeyName) == -1) {\n            console.error('public key \"', options.publicKeyName, '\" not found.');\n            return;\n        }\n        if (getKey(options.privateKeyName).type != 'mixed') {\n            if (getKey(options.privateKeyName).type != 'private') {\n                console.error('key \"', options.privateKeyName, '\" is not a valid private key.');\n                return;\n            }\n            if (getKey(options.publicKeyName).type != 'public') {\n                console.error('key \"', options.publicKeyName, '\" is not a valid public key.');\n                return;\n            }\n        }\n        // == Establecer defectos si no se han definido.            \n        if (!tools.isDefined(options.targetClass)) {\n            options.targetClass = 'AES-GCM';\n        }\n        if (!tools.isDefined(options.targetLength)) {\n            options.targetLength = 256;\n        }\n        if (!tools.isDefined(options.namedCurve)) {\n            options.namedCurve = 'P-256';\n        }\n        if (!tools.isDefined(options.exportable)) {\n            options.exportable = false;\n        }\n        //console.log('public', getKey(options.publicKeyName).key);\n        // == Derivacion\n        var promise = new Promise(function (resolve, reject) {\n            crypto.subtle.deriveKey({\n                name: 'ECDH',\n                namedCurve: options.namedCurve,\n                public: getKey(options.publicKeyName).key.publicKey\n            }, getKey(options.privateKeyName).key.privateKey, {\n                name: options.targetClass,\n                length: options.targetLength\n            }, options.exportable, ['encrypt', 'decrypt']).then(function (key) {\n                key = { publicKey: key };\n                if (options.exportable) {\n                    var gRaw, gJwk;\n                    crypto.subtle.exportKey('jwk', key.publicKey).then(function (eJwk) {\n                        gJwk = eJwk;\n                        crypto.subtle.exportKey('raw', key.publicKey).then(function (eRaw) {\n                            gRaw = eRaw;\n                            cryptoKeys.push({\n                                class: options.targetClass,\n                                type: 'private',\n                                name: options.name,\n                                key: key,\n                                jwk: gJwk,\n                                raw: gRaw\n                            });\n                            if (getCryptoKey(options.name) != -1) {\n                                if (!tools.isDefined(defaultCryptoKey)) defaultCryptoKey = options.name;\n                                resolve(options.name);\n                            } else {\n                                reject('key was not added to storage.');\n                            }\n                        });\n                    }).catch(function (err) {\n                        console.error('error exporting derived key: ', err, '.');\n                        reject(err);\n                    });\n                } else {\n                    cryptoKeys.push({\n                        class: options.targetClass,\n                        type: 'private',\n                        name: options.name,\n                        key: key,\n                        jwk: null,\n                        raw: null\n                    });\n                    if (getCryptoKey(options.name) != -1) {\n                        if (!tools.isDefined(defaultCryptoKey)) defaultCryptoKey = options.name;\n                        resolve(options.name);\n                    } else {\n                        reject('key was not added to storage.');\n                    }\n                }\n            }).catch(function (err) {\n                console.log('error deriving key: ', err, '.');\n                reject(err);\n            });\n        });\n        promise.success = function (fn) {\n            promise.then(function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        promise.error = function (fn) {\n            promise.then(null, function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        return promise;\n    };\n    this.encrypt = function (options) {\n        if (tools.isDefined(options.default)) {\n            if (options.default) if (tools.isDefined(defaultCryptoKey)) {\n                options.name = defaultCryptoKey;\n            } else {\n                console.error('default key is not defined.');\n                return;\n            }\n        }\n        // == Verificacion de errores\n        if (!tools.isDefined(options.name)) {\n            console.error('key name is required for deriving ECDH keys.');\n            return;\n        }\n        if (!tools.isDefined(options.data)) {\n            console.error('data option must be defined and not null.');\n            return;\n        }\n        // == Obtener llave\n        if (getCryptoKey(options.name) == -1) {\n            console.error('Key \"', options.name, '\" not found.');\n            return;\n        }\n        // == Validar capacidad de la llave\n        if (getCryptoKey(options.name).class == 'ECDH') {\n            console.error('Key \"', options.name, '\" is not valid for encryption.');\n            return;\n        }\n        // == Defectos\n        if (!tools.isDefined(options.tagLength)) {\n            options.tagLength = 128;\n        }\n        // == IV (vector de inicializacion)\n        var encIV = crypto.getRandomValues(new Uint8Array(12));\n        // == Promesa\n        var promise = new Promise(function (resolve, reject) {\n            // == Cifrar\n            crypto.subtle.encrypt({\n                name: getCryptoKey(options.name).class,\n                iv: encIV,\n                tagLength: options.tagLength\n            }, getCryptoKey(options.name).key.publicKey, tools.StringtoAB(options.data)).then(function (encrypted) {\n                var data = {\n                    encrypted: tools.ABToHS(new Uint8Array(encrypted)),\n                    iv: tools.ABToHS(encIV)\n                };\n                // == Ejecutar promesa\n                resolve(data);\n            });\n        });\n        promise.success = function (fn) {\n            promise.then(function (data) {\n                fn(data.encrypted, data.iv);\n            });\n            return promise;\n        };\n        promise.error = function (fn) {\n            promise.then(null, function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        return promise;\n    };\n    this.decrypt = function (options) {\n        if (tools.isDefined(options.default)) {\n            if (options.default) if (tools.isDefined(defaultCryptoKey)) {\n                options.name = defaultCryptoKey;\n            } else {\n                console.error('default key is not defined.');\n                return;\n            }\n        }\n        // == Comprobacion\n        if (!tools.isDefined(options.name)) {\n            console.error('key name is required for decrypting.');\n            return;\n        }\n        if (!tools.isDefined(options.iv)) {\n            console.error('the iv is required for decrypting.');\n            return;\n        }\n        if (!tools.isDefined(options.data)) {\n            console.error('data option must be defined and not null.');\n            return;\n        }\n        // == Obtener llave\n        if (getCryptoKey(options.name) == -1) {\n            console.error('Key \"', options.name, '\" not found.');\n            return;\n        }\n        // == Validar capacidad de la llave\n        if (getCryptoKey(options.name).class == 'ECDH') {\n            console.error('Key \"', options.name, '\" is not valid for encryption.');\n            return;\n        }\n        // == Defectos\n        if (!tools.isDefined(options.tagLength)) {\n            options.tagLength = 128;\n        }\n        var promise = new Promise(function (resolve, reject) {\n            crypto.subtle.decrypt({\n                name: getCryptoKey(options.name).class,\n                iv: tools.HSToAB(options.iv),\n                tagLength: options.tagLength\n            }, getCryptoKey(options.name).key.publicKey, tools.HSToAB(options.data)).then(function (dec) {\n                data = {\n                    decrypted: tools.ABtoString(new Uint8Array(dec))\n                };\n                resolve(data);\n            }).catch(function (err) {\n                reject(err);\n            });\n        });\n        promise.success = function (fn) {\n            promise.then(function (data) {\n                fn(data.decrypted);\n            });\n            return promise;\n        };\n        promise.error = function (fn) {\n            promise.then(null, function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        return promise;\n    };\n    // == Servicio\n    this.$get = function () {\n        var $webCryptoProvider = _this;\n        return {\n            tools: {\n                ArrayBufferToHexString: function ArrayBufferToHexString(ab) {\n                    return tools.ABToHS(ab);\n                },\n                HexStringToArrayBuffer: function HexStringToArrayBuffer(hs) {\n                    return tools.HSToAB(hs);\n                },\n                ArrayBufferToString: function ArrayBufferToString(ab) {\n                    return tools.ABtoString(ab);\n                },\n                StringToArrayBuffer: function StringToArrayBuffer(str) {\n                    return tools.StringtoAB(str);\n                }\n            },\n            import: function _import(raw) {\n                var newName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n                return $webCryptoProvider.importKey({\n                    name: newName,\n                    raw: raw\n                });\n            },\n            importAndDeriveWithDefaultKey: function importAndDeriveWithDefaultKey(raw) {\n                var defKeys = $webCryptoProvider.getDefaultKeys();\n                var importName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n                var rsaKeyName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n                if (tools.isDefined(defKeys.ecdh)) {\n                    var promise = new Promise(function (resolve, reject) {\n                        $webCryptoProvider.importKey({\n                            name: importName,\n                            raw: raw\n                        }).success(function (importedKeyName) {\n                            $webCryptoProvider.derive({\n                                name: rsaKeyName,\n                                privateKeyName: defKeys.ecdh,\n                                publicKeyName: importedKeyName\n                            }).success(function (derivedKeyName) {\n                                resolve(derivedKeyName);\n                            });\n                        });\n                    });\n                    promise.success = function (fn) {\n                        promise.then(function (data) {\n                            fn(data);\n                        });\n                        return promise;\n                    };\n                    promise.error = function (fn) {\n                        promise.then(null, function (name) {\n                            fn(name);\n                        });\n                        return promise;\n                    };\n                    return promise;\n                } else {\n                    console.error('No default ECDH key defined.');\n                }\n            },\n            importAndDerive: function importAndDerive(name, raw) {\n                var importName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n                var rsaKeyName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n                var promise = new Promise(function (resolve, reject) {\n                    $webCryptoProvider.importKey({\n                        name: importName,\n                        raw: raw\n                    }).success(function (importedKeyName) {\n                        $webCryptoProvider.derive({\n                            name: rsaKeyName,\n                            privateKeyName: name,\n                            publicKeyName: importedKeyName\n                        }).success(function (derivedKeyName) {\n                            resolve(derivedKeyName);\n                        });\n                    });\n                });\n                promise.success = function (fn) {\n                    promise.then(function (data) {\n                        fn(data);\n                    });\n                    return promise;\n                };\n                promise.error = function (fn) {\n                    promise.then(null, function (name) {\n                        fn(name);\n                    });\n                    return promise;\n                };\n                return promise;\n            },\n            export: function _export(name) {\n                return $webCryptoProvider.exportKey({ name: name });\n            },\n            exportDefaultKey: function exportDefaultKey() {\n                return $webCryptoProvider.exportKey({ default: true });\n            },\n            encrypt: function encrypt(name, data) {\n                return $webCryptoProvider.encrypt({ name: name, data: data });\n            },\n            decrypt: function decrypt(name, data, iv) {\n                return $webCryptoProvider.decrypt({ name: name, data: data, iv: iv });\n            },\n            encryptWithDefaultKey: function encryptWithDefaultKey(data) {\n                return $webCryptoProvider.encrypt({ default: true, data: data });\n            },\n            decryptWithDefaultKey: function decryptWithDefaultKey(data, iv) {\n                return $webCryptoProvider.decrypt({ default: true, data: data, iv: iv });\n            }\n        };\n    };\n}).factory('$httpCrypto', function ($webCryptoProvider, $webCrypto, $http, $injector) {\n    //This service is a WIP part, not tested but should be functional, requires a compatible\n    //server.\n    var tools = $injector.instantiate(NgWebCryptoUtils);\n    return {\n        post: function post(server, data) {\n            var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            if (!tools.isDefined(server)) {\n                console.error('please define \"server\" in the options.');\n                return;\n            }\n            if (!tools.isDefined(data)) {\n                data = {};\n            }\n            if (!tools.isDefined(key)) {\n                key = $webCryptoProvider.getDefaultKeys().crypto;\n                if (!tools.isDefined(key)) {\n                    console.error('default crypto key is not defined');\n                    return;\n                }\n            }\n            if (!$webCryptoProvider.checkCryptoKey(key)) {\n                console.error('key \"', key, '\" not found.');\n                return;\n            }\n            var ucdata_str = JSON.stringify(data);\n            var promise = new Promise(function (resolve, reject) {\n                $webCryptoProvider.encrypt({\n                    name: key,\n                    data: ucdata_str\n                }).success(function (encrypted, iv) {\n                    var encData = {\n                        data: encrypted,\n                        iv: iv\n                    };\n                    $http.post(server, {\n                        d: encrypted + '.' + iv\n                    }).success(function (rdata, status, headers, config, statusText) {\n                        // == Validar respuesta\n                        if (!tools.isDefined(rdata.d)) {\n                            console.error('invalid crypto response from server.');\n                            reject(rdata);\n                            return;\n                        }\n                        if (rdata.d.indexOf(\".\") == -1) {\n                            console.error('invalid crypto response from server.');\n                            reject(rdata);\n                            return;\n                        }\n                        // == Parsear respuesta\n                        var rdatao = rdata.d.split('.')[0];\n                        var rivo = rdata.d.split('.')[1];\n                        // == Decifrar ahora\n                        $webCryptoProvider.decrypt({\n                            name: key,\n                            data: rdatao,\n                            iv: rivo\n                        }).success(function (decrypted) {\n                            try {\n                                var parsed = JSON.parse(decrypted);\n                            } catch (e) {\n                                console.error('decrypted response is not json.');\n                                reject(decrypted);\n                                return;\n                            }\n                            resultObj = {\n                                data: parsed,\n                                status: status,\n                                headers: headers,\n                                config: config,\n                                statusText: statusText,\n                                encrypted: encData\n                            };\n                            resolve(resultObj);\n                        }).error(function (err) {\n                            resultObj = {\n                                data: null,\n                                status: status,\n                                headers: headers,\n                                config: config,\n                                statusText: statusText,\n                                encrypted: encData\n                            };\n                            reject(resultObj);\n                        });\n                    }).error(function (rdata, status, headers, config, statusText) {\n                        resultObj = {\n                            data: null,\n                            status: status,\n                            headers: headers,\n                            config: config,\n                            statusText: statusText,\n                            encrypted: encData\n                        };\n                        reject(resultObj);\n                    });\n                }).error(function (err) {\n                    resultObj = {\n                        data: null,\n                        status: null,\n                        headers: null,\n                        config: config,\n                        statusText: null,\n                        encrypted: null\n                    };\n                    reject(resultObj);\n                });\n            });\n            promise.success = function (fn) {\n                promise.then(function (p) {\n                    fn(p.data);\n                });\n                return promise;\n            };\n            promise.error = function (fn) {\n                promise.then(null, function (name) {\n                    fn(name);\n                });\n                return promise;\n            };\n            return promise;\n        }\n    };\n});"]}