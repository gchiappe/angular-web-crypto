{"version":3,"sources":["ng-web-crypto.es5.js"],"names":["NgWebCryptoUtils","this","ABtoString","buffer","str","iii","byteLength","String","fromCharCode","StringtoAB","bytes","Uint8Array","length","charCodeAt","isFunction","obj","constructor","call","apply","isDefined","variable","ABToHS","uint8arr","hexStr","i","hex","toString","toUpperCase","HSToAB","a","len","push","parseInt","substr","angular","module","factory","$injector","crypto","window","subtle","console","error","tools","instantiate","keys","cryptoKeys","getKey","kName","c","name","getCryptoKey","defaultKey","defaultCryptoKey","getDefaultKeys","ecdh","checkKey","checkCryptoKey","importKey","options","crv","format","type","importDataObj","keyCapabilities","x","y","d","kty","ext","raw","promise","Promise","resolve","reject","namedCurve","then","key","gRaw","gJwk","exportKey","eJwk","eRaw","class","publicKey","jwk","catch","err","success","fn","generateKey","random","getRandomValues","default","derive","privateKeyName","publicKeyName","targetClass","targetLength","exportable","deriveKey","public","privateKey","log","encrypt","data","tagLength","encIV","iv","encrypted","decrypt","dec","decrypted","$webCryptoProvider","ArrayBufferToHexString","ab","HexStringToArrayBuffer","hs","ArrayBufferToString","StringToArrayBuffer","import","newName","importAndDeriveWithDefaultKey","defKeys","importName","rsaKeyName","importedKeyName","derivedKeyName","importAndDerive","export","exportDefaultKey","encryptWithDefaultKey","decryptWithDefaultKey","$webCrypto","$http","post","server","arguments","undefined","ucdata_str","JSON","stringify","encData","rdata","status","headers","config","statusText","indexOf","rdatao","split","rivo","parsed","parse","e","resultObj","p"],"mappings":"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","file":"ng-web-crypto.es5.min.js","sourcesContent":["/*\nngWebCrypto\n---\nThe MIT License (MIT)\n\nCopyright ©2016 Giancarlo Chiappe Aguilar\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n---\n©2016 Giancarlo Chiappe Aguilar <gchiappe@outlook.com.pe>\n*/\n'use strict';\n\nvar NgWebCryptoUtils = function () {\n    function NgWebCryptoUtils() {\n        this.ABtoString = function (buffer) {\n            var str = \"\";\n            for (var iii = 0; iii < buffer.byteLength; iii++) {\n                str += String.fromCharCode(buffer[iii]);\n            }\n            return str;\n        };\n        this.StringtoAB = function (str) {\n            var bytes = new Uint8Array(str.length);\n            for (var iii = 0; iii < str.length; iii++) {\n                bytes[iii] = str.charCodeAt(iii);\n            }\n            return bytes;\n        };\n        this.isFunction = function (obj) {\n            return !!(obj && obj.constructor && obj.call && obj.apply);\n        };\n        this.isDefined = function (variable) {\n            if (typeof variable === 'undefined' || variable === null) {\n                return false;\n            }\n            return true;\n        };\n        this.ABToHS = function (uint8arr) {\n            if (!uint8arr) {\n                return '';\n            }\n            var hexStr = '';\n            for (var i = 0; i < uint8arr.length; i++) {\n                var hex = (uint8arr[i] & 0xff).toString(16);\n                hex = hex.length === 1 ? '0' + hex : hex;\n                hexStr += hex;\n            }\n            return hexStr.toUpperCase();\n        };\n        this.HSToAB = function (str) {\n            if (!str) {\n                return new Uint8Array();\n            }\n            var a = [];\n            for (var i = 0, len = str.length; i < len; i += 2) {\n                a.push(parseInt(str.substr(i, 2), 16));\n            }\n            return new Uint8Array(a);\n        };\n    }\n    return NgWebCryptoUtils;\n}();\nangular.module('ngWebCrypto', []);\nangular.module('ngWebCrypto').factory('$webCryptoProvider', function ($injector) {\n    var crypto = window.crypto;\n    if (!crypto.subtle) {\n        console.error('ngWebCrypto: W3C WebCrypto API not supported in this browser. IE11 is not supported.');\n        return;\n    }\n    var tools = $injector.instantiate(NgWebCryptoUtils);\n    var keys = [];\n    var cryptoKeys = [];\n    var getKey = function getKey(kName) {\n        for (var c = 0; c < keys.length; c++) {\n            if (keys[c].name == kName) {\n                return keys[c];\n            }\n        }\n        return -1;\n    };\n    var getCryptoKey = function getCryptoKey(kName) {\n        for (var c = 0; c < cryptoKeys.length; c++) {\n            if (cryptoKeys[c].name == kName) {\n                return cryptoKeys[c];\n            }\n        }\n        return -1;\n    };\n    var defaultKey = null,\n        defaultCryptoKey = null;\n    return {\n        getDefaultKeys: function getDefaultKeys() {\n            return {\n                ecdh: defaultKey,\n                crypto: defaultCryptoKey\n            };\n        },\n        checkKey: function checkKey(kName) {\n            return getKey(kName) != -1;\n        },\n        checkCryptoKey: function checkCryptoKey(kName) {\n            return getCryptoKey(kName) != -1;\n        },\n        importKey: function importKey(options) {\n            if (!tools.isDefined(options.name)) {\n                console.error('key name is required for importing.');\n                return;\n            }\n            if (getKey(options.name) != -1) {\n                console.error('key name \"', options.name, '\" already in use.');\n                return;\n            }\n            if (!tools.isDefined(options.crv)) options.crv = 'P-256';\n            if (!tools.isDefined(options.format)) options.format = 'raw';\n            if (!tools.isDefined(options.type)) options.type = 'public';\n            var importDataObj;\n            var keyCapabilities = [];\n            if (options.format == 'jwk') {\n                if (!tools.isDefined(options.x) || !tools.isDefined(options.y) || !tools.isDefined(options.d)) {\n                    console.error('x, y and d parameters are required to import an ECDH key.');\n                    return;\n                }\n                importDataObj = {\n                    kty: 'EC',\n                    crv: options.crv,\n                    x: options.x,\n                    y: options.y,\n                    d: options.d,\n                    ext: true\n                };\n                if (options.type == 'private') keyCapabilities = ['deriveKey', 'deriveBits'];\n            } else {\n                if (!tools.isDefined(options.raw)) {\n                    console.error('raw parameter is missing.');\n                    return;\n                }\n                importDataObj = tools.HSToAB(options.raw);\n            }\n            var promise = new Promise(function (resolve, reject) {\n                crypto.subtle.importKey(options.format, importDataObj, {\n                    name: 'ECDH',\n                    namedCurve: options.crv\n                }, true, keyCapabilities).then(function (key) {\n                    var gRaw, gJwk;\n                    crypto.subtle.exportKey('jwk', key).then(function (eJwk) {\n                        gJwk = eJwk;\n                        crypto.subtle.exportKey('raw', key).then(function (eRaw) {\n                            gRaw = eRaw;\n                            keys.push({\n                                class: 'ECDH',\n                                type: options.type,\n                                name: options.name,\n                                key: { publicKey: key },\n                                jwk: gJwk,\n                                raw: gRaw\n                            });\n                            if (getKey(options.name) != -1) {\n                                resolve(options.name);\n                            } else {\n                                reject('key was not added to storage.');\n                            }\n                        });\n                    });\n                }).catch(function (err) {\n                    console.error('error importing key: ', err, ' check the input options.');\n                    reject('error catched.');\n                });\n            });\n            promise.success = function (fn) {\n                promise.then(function (name) {\n                    fn(name);\n                });\n                return promise;\n            };\n            promise.error = function (fn) {\n                promise.then(null, function (name) {\n                    fn(name);\n                });\n                return promise;\n            };\n            return promise;\n        },\n        generateKey: function generateKey(options) {\n            if (tools.isDefined(options.random)) {\n                if (options.random) {\n                    options.name = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n                }\n            }\n            if (!tools.isDefined(options.name)) {\n                console.error('key name is required for generating.');\n                return;\n            }\n            if (getKey(options.name) != -1) {\n                console.error('key name \"', options.name, '\" already in use.');\n                return;\n            }\n            if (!tools.isDefined(options.namedCurve)) {\n                options.namedCurve = 'P-256';\n            }\n            if (!tools.isDefined(options.type)) {\n                options.type = 'private';\n            }\n            if (!(options.type == 'private' || options.type == 'public' || options.type == 'mixed')) {\n                console.error('invalid key type (private, public, mixed).');\n                return;\n            }\n            // == Crear Promesa\n            var promise = new Promise(function (resolve, reject) {\n                // == Crear Llave\n                crypto.subtle.generateKey({\n                    name: 'ECDH',\n                    namedCurve: options.namedCurve\n                }, true, ['deriveKey', 'deriveBits']).then(function (key) {\n                    var gRaw, gJwk;\n                    crypto.subtle.exportKey('jwk', key.publicKey).then(function (eJwk) {\n                        gJwk = eJwk;\n                        crypto.subtle.exportKey('raw', key.publicKey).then(function (eRaw) {\n                            gRaw = eRaw;\n                            keys.push({\n                                class: 'ECDH',\n                                type: options.type,\n                                name: options.name,\n                                key: key,\n                                jwk: gJwk,\n                                raw: gRaw\n                            });\n                            if (getKey(options.name) != -1) {\n                                if (!tools.isDefined(defaultKey)) defaultKey = options.name;\n                                resolve(options.name);\n                            } else {\n                                reject('key was not added to storage.');\n                            }\n                        });\n                    });\n                }).catch(function (err) {\n                    reject(err);\n                });\n            });\n            promise.success = function (fn) {\n                promise.then(function (name) {\n                    fn(name);\n                });\n                return promise;\n            };\n            promise.error = function (fn) {\n                promise.then(null, function (name) {\n                    fn(name);\n                });\n                return promise;\n            };\n            return promise;\n        },\n        exportKey: function exportKey(options) {\n            // == Chequeo\n            if (tools.isDefined(options.default)) {\n                if (options.default) if (tools.isDefined(defaultKey)) {\n                    options.name = defaultKey;\n                } else {\n                    console.error('default key is not defined.');\n                    return;\n                }\n            }\n            if (!tools.isDefined(options.name)) {\n                console.error('key name is required for exporting keys.');\n                return;\n            }\n            if (getKey(options.name) == -1) {\n                console.error('Key \"', options.name, '\" not found.');\n                return;\n            }\n            // == Defectos\n            if (!tools.isDefined(options.type)) {\n                options.type = 'raw';\n            }\n            if (options.type == 'jwk') {\n                if (tools.isDefined(getKey(options.name).jwk)) return getKey(options.name).jwk;else {\n                    console.error('the key \"', options.name, '\" cannot be exported.');\n                    return;\n                }\n            } else if (options.type == 'raw') {\n                if (tools.isDefined(getKey(options.name).raw)) return tools.ABToHS(new Uint8Array(getKey(options.name).raw));else {\n                    console.error('the key \"', options.name, '\" cannot be exported.');\n                    return;\n                }\n            } else {\n                console.error('invalid export type');\n                return;\n            }\n        },\n        derive: function derive(options) {\n            // == Chequeo de errores\n            if (!tools.isDefined(options.name)) {\n                console.error('key name is required for deriving ECDH keys.');\n                return;\n            }\n            if (getCryptoKey(options.name) != -1) {\n                console.error('key name \"', options.name, '\" already in use.');\n                return;\n            }\n            if (!tools.isDefined(options.privateKeyName) || !tools.isDefined(options.publicKeyName)) {\n                console.error('deriving keys require two previously stored keys.');\n                return;\n            }\n            if (getKey(options.privateKeyName) == -1) {\n                console.error('private key \"', options.privateKeyName, '\" not found.');\n                return;\n            }\n            if (getKey(options.publicKeyName) == -1) {\n                console.error('public key \"', options.publicKeyName, '\" not found.');\n                return;\n            }\n            if (getKey(options.privateKeyName).type != 'mixed') {\n                if (getKey(options.privateKeyName).type != 'private') {\n                    console.error('key \"', options.privateKeyName, '\" is not a valid private key.');\n                    return;\n                }\n                if (getKey(options.publicKeyName).type != 'public') {\n                    console.error('key \"', options.publicKeyName, '\" is not a valid public key.');\n                    return;\n                }\n            }\n            // == Establecer defectos si no se han definido.            \n            if (!tools.isDefined(options.targetClass)) {\n                options.targetClass = 'AES-GCM';\n            }\n            if (!tools.isDefined(options.targetLength)) {\n                options.targetLength = 256;\n            }\n            if (!tools.isDefined(options.namedCurve)) {\n                options.namedCurve = 'P-256';\n            }\n            if (!tools.isDefined(options.exportable)) {\n                options.exportable = false;\n            }\n            //console.log('public', getKey(options.publicKeyName).key);\n            // == Derivacion\n            var promise = new Promise(function (resolve, reject) {\n                crypto.subtle.deriveKey({\n                    name: 'ECDH',\n                    namedCurve: options.namedCurve,\n                    public: getKey(options.publicKeyName).key.publicKey\n                }, getKey(options.privateKeyName).key.privateKey, {\n                    name: options.targetClass,\n                    length: options.targetLength\n                }, options.exportable, ['encrypt', 'decrypt']).then(function (key) {\n                    key = { publicKey: key };\n                    if (options.exportable) {\n                        var gRaw, gJwk;\n                        crypto.subtle.exportKey('jwk', key.publicKey).then(function (eJwk) {\n                            gJwk = eJwk;\n                            crypto.subtle.exportKey('raw', key.publicKey).then(function (eRaw) {\n                                gRaw = eRaw;\n                                cryptoKeys.push({\n                                    class: options.targetClass,\n                                    type: 'private',\n                                    name: options.name,\n                                    key: key,\n                                    jwk: gJwk,\n                                    raw: gRaw\n                                });\n                                if (getCryptoKey(options.name) != -1) {\n                                    if (!tools.isDefined(defaultCryptoKey)) defaultCryptoKey = options.name;\n                                    resolve(options.name);\n                                } else {\n                                    reject('key was not added to storage.');\n                                }\n                            });\n                        }).catch(function (err) {\n                            console.error('error exporting derived key: ', err, '.');\n                            reject(err);\n                        });\n                    } else {\n                        cryptoKeys.push({\n                            class: options.targetClass,\n                            type: 'private',\n                            name: options.name,\n                            key: key,\n                            jwk: null,\n                            raw: null\n                        });\n                        if (getCryptoKey(options.name) != -1) {\n                            if (!tools.isDefined(defaultCryptoKey)) defaultCryptoKey = options.name;\n                            resolve(options.name);\n                        } else {\n                            reject('key was not added to storage.');\n                        }\n                    }\n                }).catch(function (err) {\n                    console.log('error deriving key: ', err, '.');\n                    reject(err);\n                });\n            });\n            promise.success = function (fn) {\n                promise.then(function (name) {\n                    fn(name);\n                });\n                return promise;\n            };\n            promise.error = function (fn) {\n                promise.then(null, function (name) {\n                    fn(name);\n                });\n                return promise;\n            };\n            return promise;\n        },\n        encrypt: function encrypt(options) {\n            if (tools.isDefined(options.default)) {\n                if (options.default) if (tools.isDefined(defaultCryptoKey)) {\n                    options.name = defaultCryptoKey;\n                } else {\n                    console.error('default key is not defined.');\n                    return;\n                }\n            }\n            // == Verificacion de errores\n            if (!tools.isDefined(options.name)) {\n                console.error('key name is required for deriving ECDH keys.');\n                return;\n            }\n            if (!tools.isDefined(options.data)) {\n                console.error('data option must be defined and not null.');\n                return;\n            }\n            // == Obtener llave\n            if (getCryptoKey(options.name) == -1) {\n                console.error('Key \"', options.name, '\" not found.');\n                return;\n            }\n            // == Validar capacidad de la llave\n            if (getCryptoKey(options.name).class == 'ECDH') {\n                console.error('Key \"', options.name, '\" is not valid for encryption.');\n                return;\n            }\n            // == Defectos\n            if (!tools.isDefined(options.tagLength)) {\n                options.tagLength = 128;\n            }\n            // == IV (vector de inicializacion)\n            var encIV = crypto.getRandomValues(new Uint8Array(12));\n            // == Promesa\n            var promise = new Promise(function (resolve, reject) {\n                // == Cifrar\n                crypto.subtle.encrypt({\n                    name: getCryptoKey(options.name).class,\n                    iv: encIV,\n                    tagLength: options.tagLength\n                }, getCryptoKey(options.name).key.publicKey, tools.StringtoAB(options.data)).then(function (encrypted) {\n                    var data = {\n                        encrypted: tools.ABToHS(new Uint8Array(encrypted)),\n                        iv: tools.ABToHS(encIV)\n                    };\n                    // == Ejecutar promesa\n                    resolve(data);\n                });\n            });\n            promise.success = function (fn) {\n                promise.then(function (data) {\n                    fn(data.encrypted, data.iv);\n                });\n                return promise;\n            };\n            promise.error = function (fn) {\n                promise.then(null, function (name) {\n                    fn(name);\n                });\n                return promise;\n            };\n            return promise;\n        },\n        decrypt: function decrypt(options) {\n            if (tools.isDefined(options.default)) {\n                if (options.default) if (tools.isDefined(defaultCryptoKey)) {\n                    options.name = defaultCryptoKey;\n                } else {\n                    console.error('default key is not defined.');\n                    return;\n                }\n            }\n            // == Comprobacion\n            if (!tools.isDefined(options.name)) {\n                console.error('key name is required for decrypting.');\n                return;\n            }\n            if (!tools.isDefined(options.iv)) {\n                console.error('the iv is required for decrypting.');\n                return;\n            }\n            if (!tools.isDefined(options.data)) {\n                console.error('data option must be defined and not null.');\n                return;\n            }\n            // == Obtener llave\n            if (getCryptoKey(options.name) == -1) {\n                console.error('Key \"', options.name, '\" not found.');\n                return;\n            }\n            // == Validar capacidad de la llave\n            if (getCryptoKey(options.name).class == 'ECDH') {\n                console.error('Key \"', options.name, '\" is not valid for encryption.');\n                return;\n            }\n            // == Defectos\n            if (!tools.isDefined(options.tagLength)) {\n                options.tagLength = 128;\n            }\n            var promise = new Promise(function (resolve, reject) {\n                crypto.subtle.decrypt({\n                    name: getCryptoKey(options.name).class,\n                    iv: tools.HSToAB(options.iv),\n                    tagLength: options.tagLength\n                }, getCryptoKey(options.name).key.publicKey, tools.HSToAB(options.data)).then(function (dec) {\n                    data = {\n                        decrypted: tools.ABtoString(new Uint8Array(dec))\n                    };\n                    resolve(data);\n                }).catch(function (err) {\n                    reject(err);\n                });\n            });\n            promise.success = function (fn) {\n                promise.then(function (data) {\n                    fn(data.decrypted);\n                });\n                return promise;\n            };\n            promise.error = function (fn) {\n                promise.then(null, function (name) {\n                    fn(name);\n                });\n                return promise;\n            };\n            return promise;\n        }\n    };\n}).factory('$webCrypto', function ($webCryptoProvider, $injector) {\n    var tools = $injector.instantiate(NgWebCryptoUtils);\n    return {\n        tools: {\n            ArrayBufferToHexString: function ArrayBufferToHexString(ab) {\n                return tools.ABToHS(ab);\n            },\n            HexStringToArrayBuffer: function HexStringToArrayBuffer(hs) {\n                return tools.HSToAB(hs);\n            },\n            ArrayBufferToString: function ArrayBufferToString(ab) {\n                return tools.ABtoString(ab);\n            },\n            StringToArrayBuffer: function StringToArrayBuffer(str) {\n                return tools.StringtoAB(str);\n            }\n        },\n        import: function _import(raw) {\n            var newName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n            return $webCryptoProvider.importKey({\n                name: newName,\n                raw: raw\n            });\n        },\n        importAndDeriveWithDefaultKey: function importAndDeriveWithDefaultKey(raw) {\n            var defKeys = $webCryptoProvider.getDefaultKeys();\n            var importName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n            var rsaKeyName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n            if (tools.isDefined(defKeys.ecdh)) {\n                var promise = new Promise(function (resolve, reject) {\n                    $webCryptoProvider.importKey({\n                        name: importName,\n                        raw: raw\n                    }).success(function (importedKeyName) {\n                        $webCryptoProvider.derive({\n                            name: rsaKeyName,\n                            privateKeyName: defKeys.ecdh,\n                            publicKeyName: importedKeyName\n                        }).success(function (derivedKeyName) {\n                            resolve(derivedKeyName);\n                        });\n                    });\n                });\n                promise.success = function (fn) {\n                    promise.then(function (data) {\n                        fn(data);\n                    });\n                    return promise;\n                };\n                promise.error = function (fn) {\n                    promise.then(null, function (name) {\n                        fn(name);\n                    });\n                    return promise;\n                };\n                return promise;\n            } else {\n                console.error('No default ECDH key defined.');\n            }\n        },\n        importAndDerive: function importAndDerive(name, raw) {\n            var importName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n            var rsaKeyName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n            var promise = new Promise(function (resolve, reject) {\n                $webCryptoProvider.importKey({\n                    name: importName,\n                    raw: raw\n                }).success(function (importedKeyName) {\n                    $webCryptoProvider.derive({\n                        name: rsaKeyName,\n                        privateKeyName: name,\n                        publicKeyName: importedKeyName\n                    }).success(function (derivedKeyName) {\n                        resolve(derivedKeyName);\n                    });\n                });\n            });\n            promise.success = function (fn) {\n                promise.then(function (data) {\n                    fn(data);\n                });\n                return promise;\n            };\n            promise.error = function (fn) {\n                promise.then(null, function (name) {\n                    fn(name);\n                });\n                return promise;\n            };\n            return promise;\n        },\n        export: function _export(name) {\n            return $webCryptoProvider.exportKey({ name: name });\n        },\n        exportDefaultKey: function exportDefaultKey() {\n            return $webCryptoProvider.exportKey({ default: true });\n        },\n        encrypt: function encrypt(name, data) {\n            return $webCryptoProvider.encrypt({ name: name, data: data });\n        },\n        decrypt: function decrypt(name, data, iv) {\n            return $webCryptoProvider.decrypt({ name: name, data: data, iv: iv });\n        },\n        encryptWithDefaultKey: function encryptWithDefaultKey(data) {\n            return $webCryptoProvider.encrypt({ default: true, data: data });\n        },\n        decryptWithDefaultKey: function decryptWithDefaultKey(data, iv) {\n            return $webCryptoProvider.decrypt({ default: true, data: data, iv: iv });\n        }\n    };\n}).factory('$httpCrypto', function ($webCryptoProvider, $webCrypto, $http, $injector) {\n    var tools = $injector.instantiate(NgWebCryptoUtils);\n    return {\n        post: function post(server, data) {\n            var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            if (!tools.isDefined(server)) {\n                console.error('please define \"server\" in the options.');\n                return;\n            }\n            if (!tools.isDefined(data)) {\n                data = {};\n            }\n            if (!tools.isDefined(key)) {\n                key = $webCryptoProvider.getDefaultKeys().crypto;\n                if (!tools.isDefined(key)) {\n                    console.error('default crypto key is not defined');\n                    return;\n                }\n            }\n            if (!$webCryptoProvider.checkCryptoKey(key)) {\n                console.error('key \"', key, '\" not found.');\n                return;\n            }\n            var ucdata_str = JSON.stringify(data);\n            var promise = new Promise(function (resolve, reject) {\n                $webCryptoProvider.encrypt({\n                    name: key,\n                    data: ucdata_str\n                }).success(function (encrypted, iv) {\n                    var encData = {\n                        data: encrypted,\n                        iv: iv\n                    };\n                    $http.post(server, {\n                        d: encrypted + '.' + iv\n                    }).success(function (rdata, status, headers, config, statusText) {\n                        // == Validar respuesta\n                        if (!tools.isDefined(rdata.d)) {\n                            console.error('invalid crypto response from server.');\n                            reject(rdata);\n                            return;\n                        }\n                        if (rdata.d.indexOf(\".\") == -1) {\n                            console.error('invalid crypto response from server.');\n                            reject(rdata);\n                            return;\n                        }\n                        // == Parsear respuesta\n                        var rdatao = rdata.d.split('.')[0];\n                        var rivo = rdata.d.split('.')[1];\n                        // == Decifrar ahora\n                        $webCryptoProvider.decrypt({\n                            name: key,\n                            data: rdatao,\n                            iv: rivo\n                        }).success(function (decrypted) {\n                            try {\n                                var parsed = JSON.parse(decrypted);\n                            } catch (e) {\n                                console.error('decrypted response is not json.');\n                                reject(decrypted);\n                                return;\n                            }\n                            resultObj = {\n                                data: parsed,\n                                status: status,\n                                headers: headers,\n                                config: config,\n                                statusText: statusText,\n                                encrypted: encData\n                            };\n                            resolve(resultObj);\n                        }).error(function (err) {\n                            resultObj = {\n                                data: null,\n                                status: status,\n                                headers: headers,\n                                config: config,\n                                statusText: statusText,\n                                encrypted: encData\n                            };\n                            reject(resultObj);\n                        });\n                    }).error(function (rdata, status, headers, config, statusText) {\n                        resultObj = {\n                            data: null,\n                            status: status,\n                            headers: headers,\n                            config: config,\n                            statusText: statusText,\n                            encrypted: encData\n                        };\n                        reject(resultObj);\n                    });\n                }).error(function (err) {\n                    resultObj = {\n                        data: null,\n                        status: null,\n                        headers: null,\n                        config: config,\n                        statusText: null,\n                        encrypted: null\n                    };\n                    reject(resultObj);\n                });\n            });\n            promise.success = function (fn) {\n                promise.then(function (p) {\n                    fn(p.data);\n                });\n                return promise;\n            };\n            promise.error = function (fn) {\n                promise.then(null, function (name) {\n                    fn(name);\n                });\n                return promise;\n            };\n            return promise;\n        }\n    };\n});"]}