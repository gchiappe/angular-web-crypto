{"version":3,"sources":["ng-web-crypto.es5.js"],"names":["NgWebCryptoUtils","this","ABtoString","buffer","str","iii","byteLength","String","fromCharCode","StringtoAB","bytes","Uint8Array","length","charCodeAt","isFunction","obj","constructor","call","apply","isDefined","variable","ABToHS","uint8arr","hexStr","i","hex","toString","toUpperCase","HSToAB","a","len","push","parseInt","substr","angular","module","provider","$injector","crypto","window","subtle","tools","instantiate","keys","cryptoKeys","getKey","kName","c","name","getCryptoKey","defaultKey","defaultCryptoKey","undefined","generateKey","options","random","getRandomValues","console","error","namedCurve","type","promise","Promise","resolve","reject","then","key","gRaw","gJwk","exportKey","publicKey","eJwk","eRaw","class","jwk","raw","catch","err","success","fn","getDefaultKeys","ecdh","checkKey","checkCryptoKey","importKey","crv","format","importDataObj","keyCapabilities","x","y","d","kty","ext","default","derive","privateKeyName","publicKeyName","targetClass","targetLength","exportable","deriveKey","public","privateKey","log","encrypt","data","tagLength","encIV","iv","encrypted","decrypt","dec","decrypted","$get","$webCryptoProvider","ArrayBufferToHexString","ab","HexStringToArrayBuffer","hs","ArrayBufferToString","StringToArrayBuffer","import","newName","importAndDeriveWithDefaultKey","defKeys","importName","rsaKeyName","importedKeyName","derivedKeyName","importAndDerive","export","exportDefaultKey","encryptWithDefaultKey","decryptWithDefaultKey","factory","$webCrypto","$http","post","server","arguments","ucdata_str","JSON","stringify","encData","rdata","status","headers","config","statusText","indexOf","rdatao","split","rivo","parsed","parse","e","resultObj","p"],"mappings":"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","file":"ng-web-crypto.es5.min.js","sourcesContent":["/*\nngWebCrypto\n---\nThe MIT License (MIT)\n\ncopyright ©2016 Giancarlo A. Chiappe Aguilar\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n---\n©2016 Giancarlo Chiappe Aguilar <gchiappe@outlook.com.pe>\n*/\n'use strict';\n\nvar NgWebCryptoUtils = function () {\n    function NgWebCryptoUtils() {\n        this.ABtoString = function (buffer) {\n            var str = \"\";\n            for (var iii = 0; iii < buffer.byteLength; iii++) {\n                str += String.fromCharCode(buffer[iii]);\n            }\n            return str;\n        };\n        this.StringtoAB = function (str) {\n            var bytes = new Uint8Array(str.length);\n            for (var iii = 0; iii < str.length; iii++) {\n                bytes[iii] = str.charCodeAt(iii);\n            }\n            return bytes;\n        };\n        this.isFunction = function (obj) {\n            return !!(obj && obj.constructor && obj.call && obj.apply);\n        };\n        this.isDefined = function (variable) {\n            if (typeof variable === 'undefined' || variable === null) {\n                return false;\n            }\n            return true;\n        };\n        this.ABToHS = function (uint8arr) {\n            if (!uint8arr) {\n                return '';\n            }\n            var hexStr = '';\n            for (var i = 0; i < uint8arr.length; i++) {\n                var hex = (uint8arr[i] & 0xff).toString(16);\n                hex = hex.length === 1 ? '0' + hex : hex;\n                hexStr += hex;\n            }\n            return hexStr.toUpperCase();\n        };\n        this.HSToAB = function (str) {\n            if (!str) {\n                return new Uint8Array();\n            }\n            var a = [];\n            for (var i = 0, len = str.length; i < len; i += 2) {\n                a.push(parseInt(str.substr(i, 2), 16));\n            }\n            return new Uint8Array(a);\n        };\n    }\n    return NgWebCryptoUtils;\n}();\nangular.module('ngWebCrypto', []);\nangular.module('ngWebCrypto').provider('$webCrypto', function ($injector) {\n    var crypto = window.crypto;\n    if (!crypto.subtle) {\n        throw 'ng-web-crypto: browser not supported.';\n    }\n    var tools = $injector.instantiate(NgWebCryptoUtils);\n    //almacenes: almacenar los cripto-objetos en variables de una funcion anonima.\n    var keys = []; // llaves ECDH\n    var cryptoKeys = []; // llaves criptograficas (def. AES-GCM)\n    // llaves ECDH\n    var getKey = function getKey(kName) {\n        for (var c = 0; c < keys.length; c++) {\n            if (keys[c].name == kName) {\n                return keys[c];\n            }\n        }\n        return -1;\n    };\n    // llaves AES\n    var getCryptoKey = function getCryptoKey(kName) {\n        for (var c = 0; c < cryptoKeys.length; c++) {\n            if (cryptoKeys[c].name == kName) {\n                return cryptoKeys[c];\n            }\n        }\n        return -1;\n    };\n    var defaultKey = null,\n        defaultCryptoKey = null;\n    // Funciones del proveedor:\n    undefined.generateKey = function (options) {\n        if (tools.isDefined(options.random)) {\n            if (options.random) {\n                options.name = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n            }\n        }\n        if (!tools.isDefined(options.name)) {\n            console.error('key name is required for generating.');\n            return;\n        }\n        if (getKey(options.name) != -1) {\n            console.error('key name \"', options.name, '\" already in use.');\n            return;\n        }\n        if (!tools.isDefined(options.namedCurve)) {\n            options.namedCurve = 'P-256';\n        }\n        if (!tools.isDefined(options.type)) {\n            options.type = 'private';\n        }\n        if (!(options.type == 'private' || options.type == 'public' || options.type == 'mixed')) {\n            console.error('invalid key type (private, public, mixed).');\n            return;\n        }\n        // == Crear Promesa\n        var promise = new Promise(function (resolve, reject) {\n            // == Crear Llave\n            crypto.subtle.generateKey({\n                name: 'ECDH',\n                namedCurve: options.namedCurve\n            }, true, ['deriveKey', 'deriveBits']).then(function (key) {\n                var gRaw, gJwk;\n                crypto.subtle.exportKey('jwk', key.publicKey).then(function (eJwk) {\n                    gJwk = eJwk;\n                    crypto.subtle.exportKey('raw', key.publicKey).then(function (eRaw) {\n                        gRaw = eRaw;\n                        keys.push({\n                            class: 'ECDH',\n                            type: options.type,\n                            name: options.name,\n                            key: key,\n                            jwk: gJwk,\n                            raw: gRaw\n                        });\n                        if (getKey(options.name) != -1) {\n                            if (!tools.isDefined(defaultKey)) defaultKey = options.name;\n                            resolve(options.name);\n                        } else {\n                            reject('key was not added to storage.');\n                        }\n                    });\n                });\n            }).catch(function (err) {\n                reject(err);\n            });\n        });\n        promise.success = function (fn) {\n            promise.then(function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        promise.error = function (fn) {\n            promise.then(null, function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        return promise;\n    };\n    undefined.getDefaultKeys = function () {\n        return {\n            ecdh: defaultKey,\n            crypto: defaultCryptoKey\n        };\n    };\n    undefined.checkKey = function (kName) {\n        return getKey(kName) != -1;\n    };\n    undefined.checkCryptoKey = function (kName) {\n        return getCryptoKey(kName) != -1;\n    };\n    undefined.importKey = function (options) {\n        if (!tools.isDefined(options.name)) {\n            console.error('key name is required for importing.');\n            return;\n        }\n        if (undefined.checkKey(options.name)) {\n            console.error('key name \"', options.name, '\" already in use.');\n            return;\n        }\n        if (!tools.isDefined(options.crv)) options.crv = 'P-256';\n        if (!tools.isDefined(options.format)) options.format = 'raw';\n        if (!tools.isDefined(options.type)) options.type = 'public';\n        var importDataObj = void 0;\n        var keyCapabilities = [];\n        if (options.format == 'jwk') {\n            if (!tools.isDefined(options.x) || !tools.isDefined(options.y) || !tools.isDefined(options.d)) {\n                throw 'x, y and d parameters are required to import an ECDH key.';\n            }\n            importDataObj = {\n                kty: 'EC',\n                crv: options.crv,\n                x: options.x,\n                y: options.y,\n                d: options.d,\n                ext: true\n            };\n            if (options.type == 'private') keyCapabilities = ['deriveKey', 'deriveBits'];\n        } else {\n            if (!tools.isDefined(options.raw)) {\n                throw 'raw parameter is missing.';\n            }\n            importDataObj = tools.HSToAB(options.raw);\n        }\n        var promise = new Promise(function (resolve, reject) {\n            crypto.subtle.importKey(options.format, importDataObj, {\n                name: 'ECDH',\n                namedCurve: options.crv\n            }, true, keyCapabilities).then(function (key) {\n                var gRaw = void 0,\n                    gJwk = void 0;\n                crypto.subtle.exportKey('jwk', key).then(function (eJwk) {\n                    gJwk = eJwk;\n                    crypto.subtle.exportKey('raw', key).then(function (eRaw) {\n                        gRaw = eRaw;\n                        keys.push({\n                            class: 'ECDH',\n                            type: options.type,\n                            name: options.name,\n                            key: { publicKey: key },\n                            jwk: gJwk,\n                            raw: gRaw\n                        });\n                        if (getKey(options.name) != -1) {\n                            resolve(options.name);\n                        } else {\n                            reject('key was not added to storage.');\n                        }\n                    });\n                });\n            }).catch(function (err) {\n                reject('error catched.');\n                throw err;\n            });\n        });\n        promise.success = function (fn) {\n            promise.then(function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        promise.error = function (fn) {\n            promise.then(null, function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        return promise;\n    };\n    undefined.exportKey = function (options) {\n        // == Chequeo\n        if (tools.isDefined(options.default)) {\n            if (options.default) if (tools.isDefined(defaultKey)) {\n                options.name = defaultKey;\n            } else {\n                console.error('default key is not defined.');\n                return;\n            }\n        }\n        if (!tools.isDefined(options.name)) {\n            console.error('key name is required for exporting keys.');\n            return;\n        }\n        if (getKey(options.name) == -1) {\n            console.error('Key \"', options.name, '\" not found.');\n            return;\n        }\n        // == Defectos\n        if (!tools.isDefined(options.type)) {\n            options.type = 'raw';\n        }\n        if (options.type == 'jwk') {\n            if (tools.isDefined(getKey(options.name).jwk)) return getKey(options.name).jwk;else {\n                console.error('the key \"', options.name, '\" cannot be exported.');\n                return;\n            }\n        } else if (options.type == 'raw') {\n            if (tools.isDefined(getKey(options.name).raw)) return tools.ABToHS(new Uint8Array(getKey(options.name).raw));else {\n                console.error('the key \"', options.name, '\" cannot be exported.');\n                return;\n            }\n        } else {\n            console.error('invalid export type');\n            return;\n        }\n    };\n    undefined.derive = function (options) {\n        // == Chequeo de errores\n        if (!tools.isDefined(options.name)) {\n            console.error('key name is required for deriving ECDH keys.');\n            return;\n        }\n        if (getCryptoKey(options.name) != -1) {\n            console.error('key name \"', options.name, '\" already in use.');\n            return;\n        }\n        if (!tools.isDefined(options.privateKeyName) || !tools.isDefined(options.publicKeyName)) {\n            console.error('deriving keys require two previously stored keys.');\n            return;\n        }\n        if (getKey(options.privateKeyName) == -1) {\n            console.error('private key \"', options.privateKeyName, '\" not found.');\n            return;\n        }\n        if (getKey(options.publicKeyName) == -1) {\n            console.error('public key \"', options.publicKeyName, '\" not found.');\n            return;\n        }\n        if (getKey(options.privateKeyName).type != 'mixed') {\n            if (getKey(options.privateKeyName).type != 'private') {\n                console.error('key \"', options.privateKeyName, '\" is not a valid private key.');\n                return;\n            }\n            if (getKey(options.publicKeyName).type != 'public') {\n                console.error('key \"', options.publicKeyName, '\" is not a valid public key.');\n                return;\n            }\n        }\n        // == Establecer defectos si no se han definido.            \n        if (!tools.isDefined(options.targetClass)) {\n            options.targetClass = 'AES-GCM';\n        }\n        if (!tools.isDefined(options.targetLength)) {\n            options.targetLength = 256;\n        }\n        if (!tools.isDefined(options.namedCurve)) {\n            options.namedCurve = 'P-256';\n        }\n        if (!tools.isDefined(options.exportable)) {\n            options.exportable = false;\n        }\n        //console.log('public', getKey(options.publicKeyName).key);\n        // == Derivacion\n        var promise = new Promise(function (resolve, reject) {\n            crypto.subtle.deriveKey({\n                name: 'ECDH',\n                namedCurve: options.namedCurve,\n                public: getKey(options.publicKeyName).key.publicKey\n            }, getKey(options.privateKeyName).key.privateKey, {\n                name: options.targetClass,\n                length: options.targetLength\n            }, options.exportable, ['encrypt', 'decrypt']).then(function (key) {\n                key = { publicKey: key };\n                if (options.exportable) {\n                    var gRaw, gJwk;\n                    crypto.subtle.exportKey('jwk', key.publicKey).then(function (eJwk) {\n                        gJwk = eJwk;\n                        crypto.subtle.exportKey('raw', key.publicKey).then(function (eRaw) {\n                            gRaw = eRaw;\n                            cryptoKeys.push({\n                                class: options.targetClass,\n                                type: 'private',\n                                name: options.name,\n                                key: key,\n                                jwk: gJwk,\n                                raw: gRaw\n                            });\n                            if (getCryptoKey(options.name) != -1) {\n                                if (!tools.isDefined(defaultCryptoKey)) defaultCryptoKey = options.name;\n                                resolve(options.name);\n                            } else {\n                                reject('key was not added to storage.');\n                            }\n                        });\n                    }).catch(function (err) {\n                        console.error('error exporting derived key: ', err, '.');\n                        reject(err);\n                    });\n                } else {\n                    cryptoKeys.push({\n                        class: options.targetClass,\n                        type: 'private',\n                        name: options.name,\n                        key: key,\n                        jwk: null,\n                        raw: null\n                    });\n                    if (getCryptoKey(options.name) != -1) {\n                        if (!tools.isDefined(defaultCryptoKey)) defaultCryptoKey = options.name;\n                        resolve(options.name);\n                    } else {\n                        reject('key was not added to storage.');\n                    }\n                }\n            }).catch(function (err) {\n                console.log('error deriving key: ', err, '.');\n                reject(err);\n            });\n        });\n        promise.success = function (fn) {\n            promise.then(function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        promise.error = function (fn) {\n            promise.then(null, function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        return promise;\n    };\n    undefined.encrypt = function (options) {\n        if (tools.isDefined(options.default)) {\n            if (options.default) if (tools.isDefined(defaultCryptoKey)) {\n                options.name = defaultCryptoKey;\n            } else {\n                console.error('default key is not defined.');\n                return;\n            }\n        }\n        // == Verificacion de errores\n        if (!tools.isDefined(options.name)) {\n            console.error('key name is required for deriving ECDH keys.');\n            return;\n        }\n        if (!tools.isDefined(options.data)) {\n            console.error('data option must be defined and not null.');\n            return;\n        }\n        // == Obtener llave\n        if (getCryptoKey(options.name) == -1) {\n            console.error('Key \"', options.name, '\" not found.');\n            return;\n        }\n        // == Validar capacidad de la llave\n        if (getCryptoKey(options.name).class == 'ECDH') {\n            console.error('Key \"', options.name, '\" is not valid for encryption.');\n            return;\n        }\n        // == Defectos\n        if (!tools.isDefined(options.tagLength)) {\n            options.tagLength = 128;\n        }\n        // == IV (vector de inicializacion)\n        var encIV = crypto.getRandomValues(new Uint8Array(12));\n        // == Promesa\n        var promise = new Promise(function (resolve, reject) {\n            // == Cifrar\n            crypto.subtle.encrypt({\n                name: getCryptoKey(options.name).class,\n                iv: encIV,\n                tagLength: options.tagLength\n            }, getCryptoKey(options.name).key.publicKey, tools.StringtoAB(options.data)).then(function (encrypted) {\n                var data = {\n                    encrypted: tools.ABToHS(new Uint8Array(encrypted)),\n                    iv: tools.ABToHS(encIV)\n                };\n                // == Ejecutar promesa\n                resolve(data);\n            });\n        });\n        promise.success = function (fn) {\n            promise.then(function (data) {\n                fn(data.encrypted, data.iv);\n            });\n            return promise;\n        };\n        promise.error = function (fn) {\n            promise.then(null, function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        return promise;\n    };\n    undefined.decrypt = function (options) {\n        if (tools.isDefined(options.default)) {\n            if (options.default) if (tools.isDefined(defaultCryptoKey)) {\n                options.name = defaultCryptoKey;\n            } else {\n                console.error('default key is not defined.');\n                return;\n            }\n        }\n        // == Comprobacion\n        if (!tools.isDefined(options.name)) {\n            console.error('key name is required for decrypting.');\n            return;\n        }\n        if (!tools.isDefined(options.iv)) {\n            console.error('the iv is required for decrypting.');\n            return;\n        }\n        if (!tools.isDefined(options.data)) {\n            console.error('data option must be defined and not null.');\n            return;\n        }\n        // == Obtener llave\n        if (getCryptoKey(options.name) == -1) {\n            console.error('Key \"', options.name, '\" not found.');\n            return;\n        }\n        // == Validar capacidad de la llave\n        if (getCryptoKey(options.name).class == 'ECDH') {\n            console.error('Key \"', options.name, '\" is not valid for encryption.');\n            return;\n        }\n        // == Defectos\n        if (!tools.isDefined(options.tagLength)) {\n            options.tagLength = 128;\n        }\n        var promise = new Promise(function (resolve, reject) {\n            crypto.subtle.decrypt({\n                name: getCryptoKey(options.name).class,\n                iv: tools.HSToAB(options.iv),\n                tagLength: options.tagLength\n            }, getCryptoKey(options.name).key.publicKey, tools.HSToAB(options.data)).then(function (dec) {\n                data = {\n                    decrypted: tools.ABtoString(new Uint8Array(dec))\n                };\n                resolve(data);\n            }).catch(function (err) {\n                reject(err);\n            });\n        });\n        promise.success = function (fn) {\n            promise.then(function (data) {\n                fn(data.decrypted);\n            });\n            return promise;\n        };\n        promise.error = function (fn) {\n            promise.then(null, function (name) {\n                fn(name);\n            });\n            return promise;\n        };\n        return promise;\n    };\n    // == Servicio\n    undefined.$get = function () {\n        var $webCryptoProvider = undefined;\n        return {\n            tools: {\n                ArrayBufferToHexString: function ArrayBufferToHexString(ab) {\n                    return tools.ABToHS(ab);\n                },\n                HexStringToArrayBuffer: function HexStringToArrayBuffer(hs) {\n                    return tools.HSToAB(hs);\n                },\n                ArrayBufferToString: function ArrayBufferToString(ab) {\n                    return tools.ABtoString(ab);\n                },\n                StringToArrayBuffer: function StringToArrayBuffer(str) {\n                    return tools.StringtoAB(str);\n                }\n            },\n            import: function _import(raw) {\n                var newName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n                return $webCryptoProvider.importKey({\n                    name: newName,\n                    raw: raw\n                });\n            },\n            importAndDeriveWithDefaultKey: function importAndDeriveWithDefaultKey(raw) {\n                var defKeys = $webCryptoProvider.getDefaultKeys();\n                var importName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n                var rsaKeyName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n                if (tools.isDefined(defKeys.ecdh)) {\n                    var promise = new Promise(function (resolve, reject) {\n                        $webCryptoProvider.importKey({\n                            name: importName,\n                            raw: raw\n                        }).success(function (importedKeyName) {\n                            $webCryptoProvider.derive({\n                                name: rsaKeyName,\n                                privateKeyName: defKeys.ecdh,\n                                publicKeyName: importedKeyName\n                            }).success(function (derivedKeyName) {\n                                resolve(derivedKeyName);\n                            });\n                        });\n                    });\n                    promise.success = function (fn) {\n                        promise.then(function (data) {\n                            fn(data);\n                        });\n                        return promise;\n                    };\n                    promise.error = function (fn) {\n                        promise.then(null, function (name) {\n                            fn(name);\n                        });\n                        return promise;\n                    };\n                    return promise;\n                } else {\n                    console.error('No default ECDH key defined.');\n                }\n            },\n            importAndDerive: function importAndDerive(name, raw) {\n                var importName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n                var rsaKeyName = tools.ABToHS(crypto.getRandomValues(new Uint8Array(12)));\n                var promise = new Promise(function (resolve, reject) {\n                    $webCryptoProvider.importKey({\n                        name: importName,\n                        raw: raw\n                    }).success(function (importedKeyName) {\n                        $webCryptoProvider.derive({\n                            name: rsaKeyName,\n                            privateKeyName: name,\n                            publicKeyName: importedKeyName\n                        }).success(function (derivedKeyName) {\n                            resolve(derivedKeyName);\n                        });\n                    });\n                });\n                promise.success = function (fn) {\n                    promise.then(function (data) {\n                        fn(data);\n                    });\n                    return promise;\n                };\n                promise.error = function (fn) {\n                    promise.then(null, function (name) {\n                        fn(name);\n                    });\n                    return promise;\n                };\n                return promise;\n            },\n            export: function _export(name) {\n                return $webCryptoProvider.exportKey({ name: name });\n            },\n            exportDefaultKey: function exportDefaultKey() {\n                return $webCryptoProvider.exportKey({ default: true });\n            },\n            encrypt: function encrypt(name, data) {\n                return $webCryptoProvider.encrypt({ name: name, data: data });\n            },\n            decrypt: function decrypt(name, data, iv) {\n                return $webCryptoProvider.decrypt({ name: name, data: data, iv: iv });\n            },\n            encryptWithDefaultKey: function encryptWithDefaultKey(data) {\n                return $webCryptoProvider.encrypt({ default: true, data: data });\n            },\n            decryptWithDefaultKey: function decryptWithDefaultKey(data, iv) {\n                return $webCryptoProvider.decrypt({ default: true, data: data, iv: iv });\n            }\n        };\n    };\n}).factory('$httpCrypto', function ($webCryptoProvider, $webCrypto, $http, $injector) {\n    //This service is a WIP part, not tested but should be functional, requires a compatible\n    //server.\n    var tools = $injector.instantiate(NgWebCryptoUtils);\n    return {\n        post: function post(server, data) {\n            var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            if (!tools.isDefined(server)) {\n                console.error('please define \"server\" in the options.');\n                return;\n            }\n            if (!tools.isDefined(data)) {\n                data = {};\n            }\n            if (!tools.isDefined(key)) {\n                key = $webCryptoProvider.getDefaultKeys().crypto;\n                if (!tools.isDefined(key)) {\n                    console.error('default crypto key is not defined');\n                    return;\n                }\n            }\n            if (!$webCryptoProvider.checkCryptoKey(key)) {\n                console.error('key \"', key, '\" not found.');\n                return;\n            }\n            var ucdata_str = JSON.stringify(data);\n            var promise = new Promise(function (resolve, reject) {\n                $webCryptoProvider.encrypt({\n                    name: key,\n                    data: ucdata_str\n                }).success(function (encrypted, iv) {\n                    var encData = {\n                        data: encrypted,\n                        iv: iv\n                    };\n                    $http.post(server, {\n                        d: encrypted + '.' + iv\n                    }).success(function (rdata, status, headers, config, statusText) {\n                        // == Validar respuesta\n                        if (!tools.isDefined(rdata.d)) {\n                            console.error('invalid crypto response from server.');\n                            reject(rdata);\n                            return;\n                        }\n                        if (rdata.d.indexOf(\".\") == -1) {\n                            console.error('invalid crypto response from server.');\n                            reject(rdata);\n                            return;\n                        }\n                        // == Parsear respuesta\n                        var rdatao = rdata.d.split('.')[0];\n                        var rivo = rdata.d.split('.')[1];\n                        // == Decifrar ahora\n                        $webCryptoProvider.decrypt({\n                            name: key,\n                            data: rdatao,\n                            iv: rivo\n                        }).success(function (decrypted) {\n                            try {\n                                var parsed = JSON.parse(decrypted);\n                            } catch (e) {\n                                console.error('decrypted response is not json.');\n                                reject(decrypted);\n                                return;\n                            }\n                            resultObj = {\n                                data: parsed,\n                                status: status,\n                                headers: headers,\n                                config: config,\n                                statusText: statusText,\n                                encrypted: encData\n                            };\n                            resolve(resultObj);\n                        }).error(function (err) {\n                            resultObj = {\n                                data: null,\n                                status: status,\n                                headers: headers,\n                                config: config,\n                                statusText: statusText,\n                                encrypted: encData\n                            };\n                            reject(resultObj);\n                        });\n                    }).error(function (rdata, status, headers, config, statusText) {\n                        resultObj = {\n                            data: null,\n                            status: status,\n                            headers: headers,\n                            config: config,\n                            statusText: statusText,\n                            encrypted: encData\n                        };\n                        reject(resultObj);\n                    });\n                }).error(function (err) {\n                    resultObj = {\n                        data: null,\n                        status: null,\n                        headers: null,\n                        config: config,\n                        statusText: null,\n                        encrypted: null\n                    };\n                    reject(resultObj);\n                });\n            });\n            promise.success = function (fn) {\n                promise.then(function (p) {\n                    fn(p.data);\n                });\n                return promise;\n            };\n            promise.error = function (fn) {\n                promise.then(null, function (name) {\n                    fn(name);\n                });\n                return promise;\n            };\n            return promise;\n        }\n    };\n});"]}